# 八数码难题
通过单步移动把下面的矩阵移动成1-8环绕一周的矩阵（即0在中间，1-8顺序排成一圈，1在哪儿无所谓）  
<p align="center">
	<img src="https://github.com/KevinNum1/IntelligentSearch/blob/master/images/figure8matrix.png" width="93" height="93">
</p>
分别用广度优先搜索、深度优先搜索和启发式搜索算法 A* 算法进行搜索。

# Requirements
支持 C99 标准的 C 语言环境


# 程序说明
该程序采用 C 语言实现，分别采用 A\* 算法、广度优先搜索算法和深度优先搜索算法。所有搜索算法具体步骤都可归纳如下：  
```
1. 把初始节点 S0 放入 Open 表中；  
2. 检查 Open 表是否为空，若为空，则问题无解，失败退出；  
3. 把 Open 表的第一个节点取出放入 Closed 表，并记该节点为节点 n；  
4. 考察节点 n 是否为目标节点。若是则得到了问题的解，成功退出；  
5. 若节点 n 不可扩展，则转第 2 步；  
6. 扩展节点 n，生成一组子节点。遍历 Closed 表，判断子节点是否是重复节点；  
   重复节点删除策略：若子节点是重复节点 且 深度大于原节点，则删除；  
7. 将子节点插入到 Open 表中，三种搜索算法对应三种不同的插入策略：
	广度优先搜索：将子节点插入到 Open 表的尾部；
	深度优先搜索：将子节点插入到 Open 表的首部；
	A* 算法:依据估价函数值寻找正确的插入位置，维护一个依估价函数值有序的链表；
8. 转第 2 步。  
```

我们用二维数组保存八数码矩阵，八数码结构体共包含八数码矩阵、在搜索树中的深度、估价函数值及指向父节点的指针。  
定义如下：  
```c
typedef struct status
{
	char chessboard[3][3];
	int deep;
	int f;
	struct status * parent;
} Item;
```

由于在无解情况下，A\* 算法需要遍历9!/2=181440种情况，与广度优先搜索和深度优先搜索相同，所需要的时间和空间开销都较大，故采用计算排列的逆序数的方法来判断两种八数码状态是否可达：  
```
逆序数：  
在 n 个元素的任一排列中，当某两个元素的先后次序与标准次序不同时，就说有一个逆序。  
一个排序中的所有逆序的总数叫做这个排列的逆序数。
设 P1 P2 …… Pn 为 n 个自然数的一个排列，  
考虑元素 Pi(i=1,2,……,n),如果比 Pi 大的且排在 Pi 前面的元素有 Ti 个，就说 Pi 这个元素的逆序数是 Ti，  
全体元素的逆序数之总和即是这个排列的逆序数。
```
考虑八数码难题：将八数码展开成一维数组，计算除0以外所有数的逆序数之和，如果两个状态的逆序数奇偶性不同，则这两个状态不可达；反之，则可达。代码中采用函数calculateReverseOrder实现。  

程序分别实现了两种启发函数：  
* 启发函数一：W(n) 表示节点 n 中与目标状态相比“不在位”的数码个数；  
* 启发函数二：W(n) 定义为每一个数码与其目标位置之间距离（不考虑夹在其间的数码）的总和。  

在 list.c 中通过设置宏 METHOD 的值为 1 或 2 可以选择采用启发函数一或启发函数二，包含在函数setF中。（使用启发函数二搜索速度远快于启发函数一。）  

程序采用**多文件编译**：  
* list.h 包含结构体的定义及链表各操作的函数原型；  
* list.c 包含链表各操作的函数实现；  
* Figure8Puzzle2019.c 包含 main() 函数。  

程序首先展示了两个示例，示例一即为题目所求，可以看到，我们的程序不仅能输出最少步数，还能输出所有的最短路径操作；示例二从初始状态最少需要移动16步才能移动成1-8环绕一周，因此是测试程序的绝佳例子，我们的代码依然表现得很好；该程序还允许用户自行输入初始状态和目标状态，可玩性很高，并设置了出口：当用户在初始状态中输入q时程序退出。
