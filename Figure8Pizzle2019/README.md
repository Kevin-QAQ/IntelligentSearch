# 八数码难题
通过单步移动把下面的矩阵移动成1-8环绕一周的矩阵（即0在中间，1-8顺序排成一圈，1在哪儿无所谓）  
$$
 \left[
 \begin{matrix}
   2 & 8 & 3 \\
   1 & 6 & 4 \\
   7 & 0 & 5
  \end{matrix}
  \right] \tag{3}
$$

##程序说明
该程序采用C语言实现，分别采用A*算法、广度优先搜索算法和深度优先搜索算法。所有搜索算法具体步骤都可归纳如下：  
*(1)	把初始节点S0放入Open表，并建立目前仅包含S0的图G；  
*(2)	检查Open表是否为空，若为空，则问题无解，失败退出；  
*(3)	把Open表的第一个节点取出放入Closed表，并记该节点为节点n；  
*(4)	考察节点n是否为目标节点。若是则得到了问题的解，成功退出；  
*(5)	扩展节点n，生成一组子节点。把这些子节点中不是节点n先辈的那部分子节点记入集合M，并把这些子节点作为节点n的子节点加入G中；  
*(6)	针对M中子节点的不同情况，分别作如下处理：  
*<1>	对那些没有在G中出现过的M成员设置一个指向其父节点（即节点n）的指针，并把它放入Open表。（新生成的）  
*<2>	对那些原来已在G中出现过，但还没有被扩展的M成员，确定是否需要修改它指向父节点的指针。（原生成但未扩展的）  
*<3>	对于那些先前已在G中出现过，并已经扩展了的M成员，确定是否需要修改其后继节点指向父节点的指针。（原生成也扩展过的）  
*(7)	按某种策略对Open表中的节点进行排序。  
*(8)	转第(2)步。    
程序采用数据结构链表实现，维护两个链表openList和closeList。链表中的每个节点Node包含Item项和指向下一个节点的指针next，Item中则存储了八数码难题的状态、节点在搜索树中的深度、估价函数f的值以及指向父节点的指针。  
程序采用多文件编译：  
1)	list.h中定义了链表结点的数据结构，包含链表操作等函数的函数原型声明；  
2)	list.c包含了所有链表操作的函数实现，计算八数码的逆序数、计算状态的估价函数、八数码的基本操作的函数以及扩展结点函数的实现；  
3)	Figure8Puzzle.c中是main函数。通过遍历所有可能的1-8环绕一周的16个目标状态来求解出最短路径解。  
链表操作和简单的八数码操作主要有：  
函数AddItem向有序链表中添加一个节点，由于维护的是一个有序链表，因此无需对链表进行排序操作（在插入时寻找正确的插入位置）；函数headInserted向链表中用头插法插入一个节点；tailInserted向链表中用尾插法插入一个节点；函数Traverse遍历一个链表，判断一个Item是否在该链表中；函数count为比较Item与Target中相同位置不同元素的个数，若为0则表示两个状态相同；函数getRowAndColumn为计算一个状态中某个数的行号和列号；函数showItem为显示一个Item；由于每个节点有一个指向父节点的指针，因此当找到正确的节点之后，可以使用函数display，尾递归地显示操作步骤。  
核心函数解释：  
Expand函数扩展一个节点，并将扩展出来的未出现过的节点有序地加入openList表中。主要的方法是找到八数码状态中空格（用数字0表示）的位置，然后考察0上下左右是否有数字可以移动到0处来扩展出新的结点。  
特别需要注意的一点是，如果扩展出来的结点状态之前已经搜索过，那么当扩展出来的状态在搜索树中的深度比之前深的时候删除新扩展的结点（已经搜索过了！）。之所以还要保留相同深度的同一个状态是为了能输出全部最短路径解。  
由于在无解情况下，A*算法需要遍历9!/2=181440种情况，与广度优先搜索相同，所需要的时间和空间开销都较大，故采用计算排列的逆序数的方法来判断两种八数码状态是否可达：
逆序数：在n个元素的任一排列中，当某两个元素的先后次序与标准次序不同时，就说有一个逆序。一个排序中的所有逆序的总数叫做这个排列的逆序数。设P1 P2 …… Pn为n个自然数的一个排列，考虑元素Pi(i=1,2,……,n),如果比Pi大的且排在Pi前面的元素有Ti个，就说Pi这个元素的逆序数是Ti，全体元素的逆序数之总和即是这个排列的逆序数。
考虑八数码难题：将八数码展开成一维数组，计算除0以外所有数的逆序数之和，如果两个状态的逆序数奇偶性不同，则这两个状态不可达；反之，则可达。代码中采用函数calculateReverseOrder实现。  
程序分别实现了两种启发函数：  
* 启发函数一：W(n)表示节点n中与目标状态相比“不在位”的数码个数；  
* 启发函数二：W(n)定义为每一个数码与其目标位置之间距离（不考虑夹在其间的数码）的总和。  
在list.c中通过设置宏METHOD的值为1或2可以选择采用启发函数一或启发函数二，包含在函数setF中。题目要求的是启发函数一，但实际上使用启发函数二搜索速度远快于启发函数一！直观的解释是，如果状态A和状态B仅有两个数字错位并不代表一定能用很少量操作从状态A移动到状态B。  
main()中AstarCalculateSteps函数负责用A*算法最快速地找到到达目标状态所需的最少步数，函数AstarFindAllSolutions、BFSearch、DFSearch分别使用A*算法、广度优先算法和深度优先算法进行搜索，根本的区别在于三者使用不同的链表插入策略：A*算法依据估价函数值维护一个有序链表；广度优先算法采用链表尾插法保证之前的层优先遍历完；深度优先算法采用链表头插法保证在搜索树的一条分支上遍历到底。在调用expand函数时通过传入method的值来控制采用不同的链表插入方法从而实现不同的搜索策略，其中宏定义了Astar为1、BFS为2、DFS为3。需要注意的是，正如前文所说，由于八数码难题状态空间十分巨大，因此深度优先搜索的最大深度被限制为事先由A*算法求得的最短步数。  
程序首先展示了两个示例，示例一即为题目所求，可以看到，我们的程序不仅能输出最少步数，还能输出所有的最短路径操作；示例二从初始状态最少需要移动16步才能移动成1-8环绕一周，因此是测试程序的绝佳例子，我们的代码依然表现得很好；该程序还允许用户自行输入初始状态和目标状态，可玩性很高，并设置了出口：当用户在初始状态中输入q时程序退出。  
