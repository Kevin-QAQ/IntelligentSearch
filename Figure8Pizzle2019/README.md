# 八数码难题
通过单步移动把下面的矩阵移动成1-8环绕一周的矩阵（即0在中间，1-8顺序排成一圈，1在哪儿无所谓）  
<p align="center">
	<img src="https://github.com/KevinNum1/IntelligentSearch/blob/master/images/figure8matrix.png" width="157" height="93">
</p>
分别用广度优先搜索、深度优先搜索和启发式搜索算法 A* 算法进行搜索。

# Requirements
支持 C99 标准的 C 语言环境


# 程序说明
该程序采用 C 语言实现，分别采用 A\* 算法、广度优先搜索算法和深度优先搜索算法。所有搜索算法具体步骤都可归纳如下：  
```
1. 把初始节点 S0 放入 Open 表，并建立目前仅包含 S0 的图 G；  
2. 检查 Open 表是否为空，若为空，则问题无解，失败退出；  
3. 把 Open 表的第一个节点取出放入 Closed 表，并记该节点为节点 n；  
4. 考察节点 n 是否为目标节点。若是则得到了问题的解，成功退出；  
5. 扩展节点n，生成一组子节点。把这些子节点中不是节点n先辈的那部分子节点记入集合M，并把这些子节点作为节点n的子节点加入G中；  
6. 针对 M 中子节点的不同情况，分别作如下处理：  
	（1） 对那些没有在 G 中出现过的 M 成员设置一个指向其父节点（即节点 n）的指针，并把它放入 Open 表。（新生成的）  
	（2） 对那些原来已在 G 中出现过，但还没有被扩展的 M 成员，确定是否需要修改它指向父节点的指针。（原生成但未扩展的）  
	（3） 对于那些先前已在G中出现过，并已经扩展了的M成员，确定是否需要修改其后继节点指向父节点的指针。（原生成也扩展过的）  
7. 按某种策略对 Open 表中的节点进行排序。  
8. 转第 2 步。  
```

我们用二维数组保存八数码矩阵，八数码结构体共包含八数码矩阵、在搜索树中的深度、估价函数值及指向父节点的指针。定义如下：  
```c
typedef struct status
{
	char chessboard[3][3];
	int deep;
	int f;
	struct status * parent;
} Item;
```

由于在无解情况下，A\* 算法需要遍历9!/2=181440种情况，与广度优先搜索和深度优先搜索相同，所需要的时间和空间开销都较大，故采用计算排列的逆序数的方法来判断两种八数码状态是否可达：  
```
逆序数：  
在 n 个元素的任一排列中，当某两个元素的先后次序与标准次序不同时，就说有一个逆序。  
一个排序中的所有逆序的总数叫做这个排列的逆序数。
设 P1 P2 …… Pn 为 n 个自然数的一个排列，  
考虑元素 Pi(i=1,2,……,n),如果比 Pi 大的且排在 Pi 前面的元素有 Ti 个，就说 Pi 这个元素的逆序数是 Ti，  
全体元素的逆序数之总和即是这个排列的逆序数。
```
考虑八数码难题：将八数码展开成一维数组，计算除0以外所有数的逆序数之和，如果两个状态的逆序数奇偶性不同，则这两个状态不可达；反之，则可达。代码中采用函数calculateReverseOrder实现。  

程序分别实现了两种启发函数：  
* 启发函数一：W(n) 表示节点 n 中与目标状态相比“不在位”的数码个数；  
* 启发函数二：W(n) 定义为每一个数码与其目标位置之间距离（不考虑夹在其间的数码）的总和。  

在 list.c 中通过设置宏 METHOD 的值为 1 或 2 可以选择采用启发函数一或启发函数二，包含在函数setF中。（使用启发函数二搜索速度远快于启发函数一。）
